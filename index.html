<!doctype html>
<html lang="ru">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Baku Card</title>
  <meta name="description" content="С днём рождения! ♥️" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="HB Kovich" />
  <meta property="og:description" content="С днём рождения! ♥️" />
  <meta property="og:image" content="optimized/poster.jpg" />
  <meta name="theme-color" content="#ffffff" />

  <!-- Preload poster for snappy playback -->
  <link rel="preload" as="image" href="optimized/poster.jpg" fetchpriority="high" />

  <!-- Favicons -->
  <link rel="apple-touch-icon" sizes="180x180" href="/favicons/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicons/favicon-16x16.png">
  <link rel="manifest" href="/favicons/site.webmanifest">

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Lora:ital,wght@0,400;0,500;0,600;0,700;1,400;1,500;1,600;1,700&display=swap');

    :root {
      --bg: #f8f8f8;
      --fg: #0f0f0f;
      --btn: #111;
      --btn-fg: #fff;
      --accent: #ff85a1;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, "Noto Sans", Arial, sans-serif;
      -webkit-font-smoothing: antialiased;
      text-rendering: optimizeLegibility;
      display: grid;
      place-items: center;
      gap: 16px;
    }

    .wrap {
      --stage-width: min(100vw, 480px);
      width: var(--stage-width);
      height: 100vh;
      padding: env(safe-area-inset-top) 0 env(safe-area-inset-bottom);
    }

    .stage {
      position: relative;
      width: 100%;
      aspect-ratio: 9/16;
      overflow: hidden;
      background: #000;
      box-shadow: 0 10px 40px rgba(0, 0, 0, .15);
    }

    video {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
      opacity: 0;
      transition: opacity 200ms linear;
    }


    .controls {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-top: 12px;
    }

    button {
      -webkit-tap-highlight-color: transparent;
      cursor: pointer;
      border: 0;
      border-radius: 999px;
      padding: 12px 18px;
      font-size: 16px;
      font-weight: 600;
      background: var(--btn);
      color: var(--btn-fg);
      box-shadow: 0 6px 18px rgba(0, 0, 0, .12);
      transition: all 200ms ease;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: scale(0.95);
    }

    .hint {
      text-align: center;
      font-size: 12px;
      opacity: .6;
      margin-top: 8px;
    }

    .loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      color: white;
      font-size: 18px;
      font-weight: 600;
      z-index: 10;
    }

    .loading-progress {
      width: 200px;
      height: 6px;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 3px;
      overflow: hidden;
      margin: 0 auto 16px;
      position: relative;
    }

    .loading-progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #ff85a1, #ff6b9d);
      border-radius: 3px;
      width: 0%;
      transition: width 0.3s ease;
      position: relative;
    }

    .loading-progress-bar::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
      animation: shimmer 1.5s infinite;
    }

    @keyframes shimmer {
      0% {
        transform: translateX(-100%);
      }

      100% {
        transform: translateX(100%);
      }
    }

    .loading-text {
      font-size: 14px;
      opacity: 0.9;
    }

    .stage.loading video {
      opacity: 0;
    }

    .main-screen {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: end;
      z-index: 20;
      opacity: 0;
      transition: opacity 0.5s ease;
    }

    .main-screen.visible {
      opacity: 1;
    }

    .poster-background {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
      opacity: 1;
    }

    .main-screen-content {
      display: flex;
      flex-direction: row;
      gap: 10px;
      margin-bottom: 17%
    }

    .main-btn {
      background: transparent;
      /* Временный яркий фон для отладки */
      border: 1.5px solid white;
      color: white;
      font-size: 14px;
      font-weight: 600;
      padding: 16px 32px;
      border-radius: 999px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
      position: relative;
      z-index: 21;
      opacity: 1 !important;
      visibility: visible !important;
      display: block !important;
      min-width: 120px;
      min-height: 50px;
    }

    .main-btn:hover {
      background: #ff85a263;
      color: white;
      box-shadow: 0 8px 24px rgba(255, 133, 161, 0.4);
    }

    .main-btn:active {
      transform: translateY(0);
    }

    .whishes-text {
      font-family: 'Lora', serif;
      font-size: calc(var(--stage-width) * 0.032);
      font-weight: 500;
      font-style: normal;
      position: absolute;
      left: 19%;
      top: 42%;
      width: 64%;
      height: 26%;
      text-align: left;
      color: #222222;
      opacity: 0;
      z-index: 21;
      transform: rotate(0.9deg);
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      justify-content: center;
      box-sizing: border-box;
      transition: opacity 1s ease, transform 1s ease;
      line-height: 1.55;
      letter-spacing: 0.1vw;
      overflow: hidden;
    }

    .wishes-content {
      display: flex;
      justify-content: flex-start;
      overflow: auto;
    }

    .whishes-text.show {
      opacity: 0.9;
    }

    .wishes-signature {
      font-family: 'Lora', serif;
      font-size: calc(var(--stage-width) * 0.028);
      font-weight: 500;
      font-style: italic;
      color: #444444;
      opacity: 0;
      pointer-events: none;
      transition: opacity 1s ease;
      text-align: right;
      line-height: 1.2;
      letter-spacing: 0.05vw;
      margin-top: 10px;
      align-self: flex-end;
    }

    .wishes-signature.show {
      opacity: 0.8;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="stage loading" id="stage">
      <!-- Индикатор загрузки -->
      <div class="loading" id="loadingIndicator">
        <div class="loading-progress">
          <div class="loading-progress-bar" id="progressBar"></div>
        </div>
        <div class="loading-text" id="loadingText">Загрузка...</div>
        <div class="loading-details" id="loadingDetails" style="font-size: 12px; opacity: 0.7; margin-top: 8px;"></div>
      </div>



      <!-- Фоновый постер, который всегда виден -->
      <img id="posterBackground" class="poster-background" src="optimized/poster.jpg" alt="Baku poster" />

      <div id="mainScreen" class="main-screen">
        <div class="main-screen-content">
          <button id="nextBtn" class="main-btn">Read</button>
          <button id="showBtn" class="main-btn">Look</button>
        </div>
      </div>

      <div id="whishesText" class="whishes-text">
        <div class="wishes-content">
          С днем рождения!<br>
          Желаю счастья, здоровья<br>
          и радости каждый день!
        </div>
        <div id="wishesSignature" class="wishes-signature">
          — Мама
        </div>
      </div>


    </div>
  </div>


  <script>
    (function () {
      const qs = new URLSearchParams(location.search);

      // Устанавливаем русские тексты напрямую

      // Map клипов (элементы будут созданы динамически)
      const clips = [
        { id: 'bouquet', el: null, src: 'optimized/bouquet_optimized.mp4', weight: 1 },
        { id: 'paper', el: null, src: 'optimized/paper_optimized.mp4', weight: 1 },
        { id: 'dance', el: null, src: 'optimized/dance_optimized.mp4', weight: 1 },
        { id: 'blowKiss', el: null, src: 'optimized/blowKiss_optimized.mp4', weight: 1 },
        { id: 'twerk', el: null, src: 'optimized/twerk_optimized.mp4', weight: 1 }
      ];

      // Массив поздравлений для динамической смены
      const wishes = [
        {
          id: 'timur-1',
          text: `"Вы помните, вы всё конечно помните". А что забыла, я вспомню за нас двоих. Обещаю, только хорошее.</br></br>Люблю. С днем рождения.`,
          signature: "— Тимур"
        },
        {
          id: 'ellada-1',
          text: `Женя, прекрасная моя кошечка, желаю тебе легкого счастливого года, сил и тепла, удачи и радости! Обнимаю крепко крепко. Надеюсь на встречу. Приветы и поздравления от моих мужчин.</br>P.S. Кстати, Тим собирается в Японию)
`,
          signature: "— Эллада"
        },
        {
          id: 'nastya-1',
          text: `Друзья, это семья которую мы выбираем сами. Я счастлива, что ты есть, что мы есть друг у друга, и спасибо, что ты моя семья. Я тебя люблю.`,
          signature: "— Настя"
        },
        {
          id: 'nastya-2',
          text: `あなたのことがぜんぶすき`,
          signature: "— Настя"
        },
        {
          id: 'marina-1',
          text: `Моя любимая фея, желаю тебе крепкого здоровья, легкости бытия и неиссякаемого вдохновения! Помни, что есть люди которые тебя любят ВСЕГДА!`,
          signature: "— Марина"
        },
        {
          id: 'adil-1',
          text: `С твоим днем, когда ты улыбаешься, летом наполняется зима, и это так прекрасно, как поездка на мотоцикле, свети !`,
          signature: "— Адиль"
        },
        {
          id: 'sergei-1',
          text: `Thank you my love for letting each other come into each others arms. I wish you love, peace, creativity and content to the next year.`,
          signature: "— Sergei"
        },
        {
          id: 'hanna-1',
          text: `Пусть все что ты называешь незаконченным, станет частью твоего бесконечного.</br></br>Люблю тебя, будь здоровенькой,`,
          signature: "— Ханна"
        },
        {
          id: 'roma-1',
          text: `больше приятных моментов как поездки в шестерке и The doors до утра, прогулок в дождливом париже и Rocky Horror picture show во время завтрака`,
          signature: "— Рома"
        },
        {
          id: 'yulik-1',
          text: `Кажется я знаю тебя всю жизнь или почти всю! И смотря на тебя возникает только тепло и чувство невероятной гордости, что в моей жизни есть человек умеющий вдохновлять и давать заряд просто своим появлением! С Днем Рождения божественная обезьянка! 🖤`,
          signature: "— Юлик"
        },
        {
          id: 'nadya-1',
          text: `Женя, я очень рада, что мы продолжаем пополнять наши локации, и сегодня мы делаем это в ?Астрахани?! Очень тебя люблю и поздравляю с твоим днем!`,
          signature: "— Надя"
        },
        {
          id: 'vadim-1',
          text: `Happy Birthday, Angel "A"! 🎉<br><br>С днем рождения, дорогая Женя! Я бесконечно горжусь нашей дружбой та и тем, что мы вообще знакомы).<br><br>Очень надеюсь, что скоро увидимся.`,
          signature: "— Вадим"
        },
        {
          id: 'vadim-2',
          text: `Желаю еще более невероятного развития в карьере — пусть Джармуш снимет тебя в своей новой картине!`,
          signature: "— Вадим"
        },
        // {
        //   id: 'david-1',
        //   text: `Старая слива<br>У храма цветет пышней.<br>С каждою весной.`,
        //   signature: "— Давид"
        // },
        {
          id: 'david-2',
          text: `Светлячки летят<br>Над летнею рекой. Твой смех<br>Теплом своим греет.`,
          signature: "— Давид"
        },
        {
          id: 'david-3',
          text: `Ветер с гор подул —<br>Сколько же журавлей<br>В небе твоих лет!<br><br>`,
          signature: "— Давид"
        },
        {
          id: 'david-4',
          text: `Пион опал,<br>Но корень его крепок.<br>Новый росток.`,
          signature: "— Давид"
        },
        {
          id: 'kirill-1',
          text: `Нас ждёт караоке в лучших столицах мира`,
          signature: "— Кирилл"
        },
        {
          id: 'kirill-2',
          text: `Спасибо что ты есть у нас, мы тебя очень любим!<br><br>Кстати, приехать в Астрахань было самой лучшей идеей, я безумно рад, что мы это сделали! Спасибо за всё`,
          signature: "— Кирилл"
        },
        {
          id: 'danya-1',
          text: `Пусть счастье накрывает волнами с завидной регулярностью и любовь живёт в сердце каждое мгновение`,
          signature: "— Даня"
        }


      ];

      // Система отслеживания просмотров поздравлений
      const WISHES_STORAGE_KEY = 'baku_wishes_views';

      // Функции для работы с localStorage
      function getWishViewCounts () {
        try {
          const stored = localStorage.getItem(WISHES_STORAGE_KEY);
          return stored ? JSON.parse(stored) : {};
        } catch (error) {
          console.error('Ошибка чтения из localStorage:', error);
          return {};
        }
      }

      function saveWishViewCounts (counts) {
        try {
          localStorage.setItem(WISHES_STORAGE_KEY, JSON.stringify(counts));
        } catch (error) {
          console.error('Ошибка сохранения в localStorage:', error);
        }
      }

      function incrementWishView (wishId) {
        const counts = getWishViewCounts();
        counts[wishId] = (counts[wishId] || 0) + 1;
        saveWishViewCounts(counts);
        return counts[wishId];
      }

      function getWishViewCount (wishId) {
        const counts = getWishViewCounts();
        return counts[wishId] || 0;
      }

      // Функция для сброса статистики (для тестирования)
      function resetWishViewCounts () {
        localStorage.removeItem(WISHES_STORAGE_KEY);
        console.log('Статистика просмотров сброшена');
      }

      // Функция выбора поздравления с наименьшим количеством просмотров
      function selectWishWithLeastViews () {
        const counts = getWishViewCounts();

        // Получаем количество просмотров для каждого поздравления
        const wishCounts = wishes.map(wish => ({
          wish: wish,
          count: counts[wish.id] || 0
        }));

        // Находим минимальное количество просмотров
        const minCount = Math.min(...wishCounts.map(wc => wc.count));

        // Выбираем из поздравлений с минимальным количеством просмотров
        let leastViewedWishes = wishCounts.filter(wc => wc.count === minCount);

        // Исключаем последнее выбранное поздравление, если есть другие варианты
        if (lastSelectedWishId && leastViewedWishes.length > 1) {
          leastViewedWishes = leastViewedWishes.filter(wc => wc.wish.id !== lastSelectedWishId);
        }

        // Если после исключения не осталось вариантов, используем все доступные
        if (leastViewedWishes.length === 0) {
          leastViewedWishes = wishCounts.filter(wc => wc.count === minCount);
        }

        // Случайно выбираем одно из поздравлений с наименьшим количеством просмотров
        const selectedWish = leastViewedWishes[Math.floor(Math.random() * leastViewedWishes.length)];

        // Запоминаем выбранное поздравление
        lastSelectedWishId = selectedWish.wish.id;

        return selectedWish.wish;
      }

      // Система предзагрузки с реальным прогрессом
      async function fetchWithProgress (url, onProgress) {
        const response = await fetch(url);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);

        const contentLength = +response.headers.get('Content-Length');
        if (!contentLength) {
          // Если размер неизвестен, загружаем как обычно
          const blob = await response.blob();
          onProgress(blob.size, blob.size);
          return blob;
        }

        const reader = response.body.getReader();
        const chunks = [];
        let receivedLength = 0;

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          chunks.push(value);
          receivedLength += value.length;
          onProgress(receivedLength, contentLength);
        }

        // Собираем все чанки в один Uint8Array
        const chunksAll = new Uint8Array(receivedLength);
        let position = 0;
        for (const chunk of chunks) {
          chunksAll.set(chunk, position);
          position += chunk.length;
        }

        return new Blob([chunksAll]);
      }

      async function preloadVideos (urls, onProgress) {
        const items = [];

        for (let i = 0; i < urls.length; i++) {
          const url = urls[i];
          const fileName = url.split('/').pop();

          onProgress(0, 100, `Загрузка ${fileName}...`, `Файл ${i + 1} из ${urls.length}`);

          const blob = await fetchWithProgress(url, (loaded, total) => {
            const fileProgress = Math.round((loaded / total) * 100);
            const overallProgress = Math.round(((i + (loaded / total)) / urls.length) * 100);
            const sizeInfo = `${Math.round(loaded / 1024)}KB / ${Math.round(total / 1024)}KB`;
            onProgress(overallProgress, 100, `Загрузка ${fileName}... ${fileProgress}%`, sizeInfo);
          });

          const objectUrl = URL.createObjectURL(blob);
          const el = document.createElement("video");
          el.src = objectUrl;
          el.muted = true;
          el.playsInline = true;
          el.style.position = 'absolute';
          el.style.inset = '0';
          el.style.width = '100%';
          el.style.height = '100%';
          el.style.objectFit = 'cover';
          el.style.opacity = '0';
          el.style.transition = 'opacity 200ms linear';

          document.getElementById('stage').appendChild(el);
          items.push({ url, objectUrl, element: el });

          onProgress(Math.round(((i + 1) / urls.length) * 100), 100, `${fileName} загружен`, 'Обработка видео...');
        }

        // Ждем готовности всех видео
        onProgress(90, 100, 'Подготовка видео...', 'Ожидание готовности к воспроизведению');
        await Promise.all(items.map(({ element }) =>
          new Promise(resolve => {
            element.addEventListener("canplaythrough", resolve, { once: true });
            element.addEventListener("loadedmetadata", resolve, { once: true });
            element.load();
          })
        ));

        return { items };
      }


      const nextBtn = document.getElementById('nextBtn');
      const showBtn = document.getElementById('showBtn');
      const stage = document.getElementById('stage');
      const loadingIndicator = document.getElementById('loadingIndicator');
      const progressBar = document.getElementById('progressBar');
      const loadingText = document.getElementById('loadingText');
      const loadingDetails = document.getElementById('loadingDetails');
      const mainScreen = document.getElementById('mainScreen');
      const whishesText = document.getElementById('whishesText');
      const wishesSignature = document.getElementById('wishesSignature');

      // Функция для смены поздравлений
      function updateWishes () {
        const selectedWish = selectWishWithLeastViews();
        const wishesContent = whishesText.querySelector('.wishes-content');
        wishesContent.innerHTML = selectedWish.text;
        wishesSignature.textContent = selectedWish.signature;

        // Для отладки - выводим статистику в консоль
        console.log('Выбрано поздравление:', selectedWish.id, 'Просмотров:', getWishViewCount(selectedWish.id));
        console.log('Общая статистика:', getWishViewCounts());

        // Возвращаем выбранное поздравление для последующего инкремента
        return selectedWish;
      }

      let lastId = null;
      let lookIndex = 0; // Индекс текущего видео для кнопки Look (по кругу)
      let current = null;
      let reverseInterval = null; // Отслеживание активного интервала обратного воспроизведения
      let isReversing = false; // Флаг для предотвращения повторных вызовов
      let lastSelectedWishId = null; // ID последнего выбранного поздравления
      let currentSelectedWish = null; // Текущее выбранное поздравление

      // Простая обработка ошибок
      function showError (message) {
        console.error(message);
      }

      // Настройки
      const CONFIG = {
        videoPlaybackRate: 1.3,
        rewindSpeed: 5.0,
        rewindInterval: 30,
        fadeDuration: 200,
        autoStartDelay: 100,
        // Скорости воспроизведения для каждого видео
        videoSpeeds: {
          'bouquet': 1.3,
          'paper': 2,    // Ускоряем paper.mp4 в 1.5 раза
          'dance': 1.3,
          'blowKiss': 1.3,
          'twerk': 1.3
        }
      };

      function pickNext () {
        // Кнопка Next всегда запускает только поздравление (paper)
        return clips.find(c => c.id === 'paper');
      }

      // Функция для выбора конкретного видео по ID
      function pickVideoById (videoId) {
        return clips.find(c => c.id === videoId);
      }

      // Функция для выбора видео для кнопки Look (по кругу)
      function pickLookVideo () {
        const lookVideos = ['bouquet', 'dance', 'blowKiss', 'twerk'];
        // Выбираем видео по кругу
        const selectedVideoId = lookVideos[lookIndex];
        // Увеличиваем индекс для следующего вызова (с возвратом к началу)
        lookIndex = (lookIndex + 1) % lookVideos.length;
        return pickVideoById(selectedVideoId);
      }

      // Функция для воспроизведения конкретного видео
      function playSpecificVideo (videoClip) {
        if (isReversing) return;

        // Скрываем кнопки при начале воспроизведения
        mainScreen.style.display = 'none';
        mainScreen.classList.remove('visible');

        // Скрываем wishes-text и подпись при начале нового видео
        whishesText.classList.remove('show');
        wishesSignature.classList.remove('show');

        if (current && current.el.currentTime > 0) {
          if (reverseInterval) {
            clearInterval(reverseInterval);
            reverseInterval = null;
          }

          isReversing = true;
          const video = current.el;

          reverseInterval = setInterval(() => {
            const newTime = video.currentTime - (CONFIG.rewindInterval / 1000) * CONFIG.rewindSpeed;

            if (newTime <= 0) {
              clearInterval(reverseInterval);
              reverseInterval = null;
              video.currentTime = 0;
              video.pause();
              current = null;
              isReversing = false;

              // Используем setTimeout для обеспечения корректной работы на iPhone
              setTimeout(() => {
                playSpecificVideo(videoClip);
              }, 50);
              return;
            } else {
              video.currentTime = newTime;
            }
          }, CONFIG.rewindInterval);
          return;
        }

        lastId = videoClip.id;
        current = videoClip;
        const videoToPlay = videoClip.el;

        // Устанавливаем скорость воспроизведения из конфига
        videoToPlay.playbackRate = CONFIG.videoSpeeds[videoClip.id] || CONFIG.videoPlaybackRate;
        videoToPlay.currentTime = 0;
        videoToPlay.addEventListener('ended', onEnded, { once: true });

        videoToPlay.style.opacity = '1';

        // Дополнительная защита для iPhone - ждем готовности видео
        const playVideo = () => {
          videoToPlay.play().catch(e => {
            console.error('Ошибка воспроизведения:', e);
            videoToPlay.style.opacity = '0';
            mainScreen.style.display = 'flex';
            mainScreen.classList.add('visible');
          });
        };

        // Проверяем готовность видео перед воспроизведением
        if (videoToPlay.readyState >= 3) { // HAVE_FUTURE_DATA
          playVideo();
        } else {
          videoToPlay.addEventListener('canplay', playVideo, { once: true });
          videoToPlay.addEventListener('loadeddata', playVideo, { once: true });
          // Fallback на случай если события не сработают
          setTimeout(playVideo, 100);
        }

        setTimeout(() => {
          clips.forEach(c => {
            if (c.id !== videoClip.id) {
              c.el.pause();
              c.el.currentTime = 0;
              c.el.style.opacity = '0';
            }
          });
        }, 200);
      }

      function fadeIn (el) {
        el.style.transition = `opacity ${CONFIG.fadeDuration}ms linear`;
        el.style.opacity = '1';
      }
      function fadeOut (el) {
        el.style.transition = `opacity ${CONFIG.fadeDuration}ms linear`;
        el.style.opacity = '0';
      }


      function stopAll () {
        if (reverseInterval) {
          clearInterval(reverseInterval);
          reverseInterval = null;
        }
        isReversing = false;
        for (const c of clips) {
          c.el.pause();
          c.el.currentTime = 0;
          c.el.style.opacity = '0';
        }
        // Скрываем wishes-text и подпись при остановке
        whishesText.classList.remove('show');
        wishesSignature.classList.remove('show');
      }

      function onEnded () {
        // Показываем wishes-text и подпись только для видео "paper"
        if (current && current.id === 'paper') {
          whishesText.classList.add('show');
          wishesSignature.classList.add('show');

          // Увеличиваем счетчик просмотров только после появления текста
          if (currentSelectedWish) {
            incrementWishView(currentSelectedWish.id);
            console.log('Поздравление просмотрено:', currentSelectedWish.id, 'Просмотров:', getWishViewCount(currentSelectedWish.id));
            currentSelectedWish = null; // Сбрасываем после использования
          }
        }

        mainScreen.style.display = 'flex';
        mainScreen.classList.add('visible');
      }


      function playNext () {
        if (isReversing) return;

        // Скрываем кнопку "Ещё раз" при начале воспроизведения
        mainScreen.style.display = 'none';
        mainScreen.classList.remove('visible');

        // Скрываем wishes-text и подпись при начале нового видео
        whishesText.classList.remove('show');
        wishesSignature.classList.remove('show');

        if (current && current.el.currentTime > 0) {
          if (reverseInterval) {
            clearInterval(reverseInterval);
            reverseInterval = null;
          }

          isReversing = true;
          const video = current.el;

          reverseInterval = setInterval(() => {
            const newTime = video.currentTime - (CONFIG.rewindInterval / 1000) * CONFIG.rewindSpeed;

            if (newTime <= 0) {
              clearInterval(reverseInterval);
              reverseInterval = null;
              video.currentTime = 0;
              video.pause();
              current = null;
              isReversing = false;

              // Используем setTimeout для обеспечения корректной работы на iPhone
              setTimeout(() => {
                playNext();
              }, 50);
              return;
            } else {
              video.currentTime = newTime;
            }
          }, CONFIG.rewindInterval);
          return;
        }

        const next = pickNext();
        lastId = next.id;
        current = next;
        const videoToPlay = next.el;

        // Обновляем поздравление только для paper видео (кнопка Next)
        if (next.id === 'paper') {
          currentSelectedWish = updateWishes();
        }

        // Устанавливаем скорость воспроизведения из конфига
        videoToPlay.playbackRate = CONFIG.videoSpeeds[next.id] || CONFIG.videoPlaybackRate;
        videoToPlay.currentTime = 0;
        videoToPlay.addEventListener('ended', onEnded, { once: true });

        videoToPlay.style.opacity = '1';

        // Дополнительная защита для iPhone - ждем готовности видео
        const playVideo = () => {
          videoToPlay.play().catch(e => {
            console.error('Ошибка воспроизведения:', e);
            videoToPlay.style.opacity = '0';
            mainScreen.style.display = 'flex';
            mainScreen.classList.add('visible');
          });
        };

        // Проверяем готовность видео перед воспроизведением
        if (videoToPlay.readyState >= 3) { // HAVE_FUTURE_DATA
          playVideo();
        } else {
          videoToPlay.addEventListener('canplay', playVideo, { once: true });
          videoToPlay.addEventListener('loadeddata', playVideo, { once: true });
          // Fallback на случай если события не сработают
          setTimeout(playVideo, 100);
        }

        setTimeout(() => {
          clips.forEach(c => {
            if (c.id !== next.id) {
              c.el.pause();
              c.el.currentTime = 0;
              c.el.style.opacity = '0';
            }
          });
        }, 200);
      }

      nextBtn.addEventListener('click', () => {
        if (!isReversing) {
          playNext();
        }
      });

      showBtn.addEventListener('click', () => {
        if (!isReversing) {
          // Выбираем видео для Look (по кругу)
          const selectedVideo = pickLookVideo();

          if (selectedVideo) {
            playSpecificVideo(selectedVideo);
          }
        }
      });

      async function waitForAssets () {
        let progress = 0;
        let currentTask = 'Инициализация...';

        function updateUI (progressValue, task, details) {
          progress = progressValue;
          progressBar.style.width = `${progress}%`;
          loadingText.textContent = task || `Загрузка... ${Math.round(progress)}%`;
          if (details) {
            loadingDetails.textContent = details;
          }
        }

        try {
          // Загружаем видео с реальным прогрессом
          const videoUrls = clips.map(c => c.src);
          const { items } = await preloadVideos(videoUrls, (progressValue, total, task, details) => {
            // Масштабируем прогресс видео от 0% до 90%
            const scaledProgress = (progressValue / 100) * 90;
            updateUI(scaledProgress, task, details);
          });

          clips.forEach((clip, index) => {
            clip.el = items[index].element;
          });

          updateUI(100, 'Готово!', 'Все ресурсы загружены');

          setTimeout(() => {
            loadingIndicator.style.display = 'none';
            stage.classList.remove('loading');
            mainScreen.classList.add('visible');
          }, 500);

        } catch (error) {
          console.error('Ошибка загрузки:', error);
          updateUI(100, 'Ошибка загрузки', error.message);
          setTimeout(() => {
            loadingIndicator.style.display = 'none';
            stage.classList.remove('loading');
            mainScreen.classList.add('visible');
          }, 500);
        }
      }

      waitForAssets();

      // Обработка событий видимости страницы - сброс в изначальное состояние при возвращении
      let isPageVisible = true;

      document.addEventListener('visibilitychange', function () {
        if (document.hidden) {
          // Страница скрыта
          isPageVisible = false;
          console.log('Страница скрыта');
        } else {
          // Страница активна - сбрасываем всё в изначальное состояние
          isPageVisible = true;
          console.log('Страница активна, сбрасываем в изначальное состояние');
          resetToInitialState();
        }
      });

      // Обработка событий фокуса окна как дополнительная защита
      window.addEventListener('blur', function () {
        console.log('Окно потеряло фокус');
      });

      window.addEventListener('focus', function () {
        console.log('Окно получило фокус, сбрасываем в изначальное состояние');
        resetToInitialState();
      });

      // Функция сброса в изначальное состояние
      function resetToInitialState () {
        // Останавливаем все видео
        stopAll();

        // Скрываем экран "Следующее"
        mainScreen.style.display = 'none';
        mainScreen.classList.remove('visible');

        // Скрываем текст поздравлений
        whishesText.classList.remove('show');
        wishesSignature.classList.remove('show');

        // Показываем главный экран с кнопками
        mainScreen.style.display = 'flex';
        mainScreen.classList.add('visible');

        // Сбрасываем текущее видео
        current = null;
        lastId = null;
        lookIndex = 0;

        console.log('Состояние сброшено в изначальное');
      }

      // Делаем функции доступными в глобальной области для отладки
      window.resetWishStats = resetWishViewCounts;
      window.getWishStats = getWishViewCounts;
      window.resetToInitial = resetToInitialState;

      // Инструкции для отладки в консоли:
      // resetWishStats() - сбросить статистику просмотров
      // getWishStats() - посмотреть текущую статистику
      // resetToInitial() - сбросить в изначальное состояние

    })();
  </script>
</body>

</html>
