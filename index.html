<!doctype html>
<html lang="ru">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Baku Card</title>
  <meta name="description" content="Открытка с плюшевым мишкой Baku: букет, лист с поздравлением, сердечко." />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Baku Card" />
  <meta property="og:description" content="Открытка с плюшевым мишкой Baku: букет, лист с поздравлением, сердечко." />
  <meta property="og:image" content="poster.png" />
  <meta name="theme-color" content="#ffffff" />

  <!-- Preload poster and videos for snappy playback -->
  <link rel="preload" as="image" href="poster.png" fetchpriority="high" />
  <link rel="preload" as="video" href="bouquet.mp4" type="video/mp4" />
  <link rel="preload" as="video" href="paper.mp4" type="video/mp4" />
  <link rel="preload" as="video" href="heart.mp4" type="video/mp4" />

  <style>
    :root {
      --bg: #f8f8f8;
      --fg: #0f0f0f;
      --btn: #111;
      --btn-fg: #fff;
      --accent: #ff85a1;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, "Noto Sans", Arial, sans-serif;
      -webkit-font-smoothing: antialiased;
      text-rendering: optimizeLegibility;
      display: grid;
      place-items: center;
      gap: 16px;
    }

    .wrap {
      width: min(100vw, 480px);
      padding: env(safe-area-inset-top) 12px env(safe-area-inset-bottom);
    }

    .stage {
      position: relative;
      width: 100%;
      aspect-ratio: 9/16;
      border-radius: 16px;
      overflow: hidden;
      background: #000;
      box-shadow: 0 10px 40px rgba(0, 0, 0, .15);
    }

    .poster,
    video {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .poster {
      opacity: 0;
      transition: opacity 250ms linear;
    }

    video {
      opacity: 0;
      transition: opacity 200ms linear;
    }

    .overlayText {
      position: absolute;
      left: 50%;
      top: 63%;
      transform: translate(-50%, -50%);
      width: 72%;
      padding: 10px 12px;
      text-align: center;
      background: rgba(255, 255, 255, 0.85);
      border-radius: 8px;
      font-size: clamp(14px, 2.6vw, 20px);
      line-height: 1.25;
      font-weight: 600;
      color: #222;
      text-wrap: balance;
      filter: drop-shadow(0 2px 6px rgba(0, 0, 0, .2));
      opacity: 0;
      transition: opacity 180ms ease-out;
      /* Tip: при необходимости сдвинь положение под свой клип */
    }

    .controls {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-top: 12px;
    }

    button {
      -webkit-tap-highlight-color: transparent;
      cursor: pointer;
      border: 0;
      border-radius: 999px;
      padding: 12px 18px;
      font-size: 16px;
      font-weight: 600;
      background: var(--btn);
      color: var(--btn-fg);
      box-shadow: 0 6px 18px rgba(0, 0, 0, .12);
      transition: all 200ms ease;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: scale(0.95);
    }

    .hint {
      text-align: center;
      font-size: 12px;
      opacity: .6;
      margin-top: 8px;
    }

    .loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      color: white;
      font-size: 18px;
      font-weight: 600;
      z-index: 10;
    }

    .loading-progress {
      width: 200px;
      height: 6px;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 3px;
      overflow: hidden;
      margin: 0 auto 16px;
      position: relative;
    }

    .loading-progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #ff85a1, #ff6b9d);
      border-radius: 3px;
      width: 0%;
      transition: width 0.3s ease;
      position: relative;
    }

    .loading-progress-bar::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
      animation: shimmer 1.5s infinite;
    }

    @keyframes shimmer {
      0% {
        transform: translateX(-100%);
      }

      100% {
        transform: translateX(100%);
      }
    }

    .loading-text {
      font-size: 14px;
      opacity: 0.9;
    }

    .stage.loading .poster,
    .stage.loading video {
      opacity: 0;
    }

    .start-screen {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 20;
      opacity: 0;
      transition: opacity 0.5s ease;
    }

    .start-screen.visible {
      opacity: 1;
    }

    .start-screen .poster {
      border-radius: 12px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
      margin-bottom: 32px;
      opacity: 1 !important;
      /* Принудительно показываем постер на экране запуска */
      background: #333;
      /* Fallback фон если изображение не загрузится */
      min-height: 200px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 14px;
    }

    .start-btn {
      background: transparent;
      /* Временный яркий фон для отладки */
      border: 2px solid white;
      color: white;
      font-size: 18px;
      font-weight: 600;
      padding: 16px 32px;
      border-radius: 999px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
      position: relative;
      z-index: 21;
      opacity: 1 !important;
      visibility: visible !important;
      display: block !important;
      min-width: 120px;
      min-height: 50px;
    }

    .start-btn:hover {
      background: #ff85a263;
      color: white;
      box-shadow: 0 8px 24px rgba(255, 133, 161, 0.4);
    }

    .start-btn:active {
      transform: translateY(0);
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="stage loading" id="stage">
      <!-- Индикатор загрузки -->
      <div class="loading" id="loadingIndicator">
        <div class="loading-progress">
          <div class="loading-progress-bar" id="progressBar"></div>
        </div>
        <div class="loading-text" id="loadingText">Загрузка...</div>
      </div>

      <img id="poster" class="poster" src="poster.png" alt="Baku poster" />

      <!-- Видеодорожки. MP4 обязателен для iOS -->
      <video id="v-bouquet" playsinline muted preload="auto" poster="poster.png"></video>
      <video id="v-paper" playsinline muted preload="auto" poster="poster.png"></video>
      <video id="v-heart" playsinline muted preload="auto" poster="poster.png"></video>

      <!-- Надпись поверх листа (показывается только во время клипа paper) -->
      <div id="overlayText" class="overlayText"></div>

      <!-- Экран запуска -->
      <div id="startScreen" class="start-screen">
        <img id="startPoster" class="poster" src="poster.png" alt="Baku poster" />
        <button id="startBtn" class="start-btn">Начать</button>
      </div>
    </div>

    <div class="controls">
      <button id="rewindBtn">На начало</button>
      <button id="againBtn">Ещё раз</button>
    </div>
    <div class="hint" id="hint">Автовоспроизведение без звука поддерживается на большинстве устройств</div>
  </div>

  <script>
    (function () {
      const qs = new URLSearchParams(location.search);
      const lang = qs.get('lang') || 'ru';
      const msg = qs.get('msg') || '';

      const STR = {
        ru: { again: 'Ещё раз', rewind: 'На начало', hint: 'Автовоспроизведение без звука поддерживается на большинстве устройств' },
        en: { again: 'Again', rewind: 'Rewind', hint: 'Autoplay without sound works on most devices' }
      };

      // UI i18n
      document.getElementById('rewindBtn').textContent = (STR[lang] || STR.ru).rewind;
      document.getElementById('againBtn').textContent = (STR[lang] || STR.ru).again;
      document.getElementById('hint').textContent = (STR[lang] || STR.ru).hint;

      // Map клипов
      const clips = [
        { id: 'bouquet', el: document.getElementById('v-bouquet'), src: 'bouquet.mp4', weight: 1 },
        { id: 'paper', el: document.getElementById('v-paper'), src: 'paper.mp4', weight: 1 },
        { id: 'heart', el: document.getElementById('v-heart'), src: 'heart.mp4', weight: 1 }
      ];

      // Поддержка WebM (не для iOS). Если рядом лежат webm — можно указать.
      const webmAlt = {
        // bouquet: 'bouquet.webm',
        // paper: 'paper.webm',
        // heart: 'heart.webm'
      };

      // Ленивая инициализация источников (избегаем двойной загрузки постера)
      for (const c of clips) {
        const canWebm = !!document.createElement('video').canPlayType('video/webm; codecs="vp9,vorbis"');
        const preferred = (canWebm && webmAlt[c.id]) ? webmAlt[c.id] : c.src;
        const source = document.createElement('source');
        source.src = preferred;
        c.el.appendChild(source);
        c.el.muted = true; c.el.playsInline = true; c.el.setAttribute('playsinline', '');
        // Обработчик ended будет добавляться динамически в playNext()
        c.el.addEventListener('error', (e) => console.warn('Video error', c.id, e));
      }

      const poster = document.getElementById('poster');
      const overlay = document.getElementById('overlayText');
      const rewindBtn = document.getElementById('rewindBtn');
      const againBtn = document.getElementById('againBtn');
      const stage = document.getElementById('stage');
      const loadingIndicator = document.getElementById('loadingIndicator');
      const progressBar = document.getElementById('progressBar');
      const loadingText = document.getElementById('loadingText');
      const startScreen = document.getElementById('startScreen');
      const startBtn = document.getElementById('startBtn');

      // Рендер текста для клипа paper
      overlay.textContent = msg;
      overlay.style.display = msg ? 'block' : 'none';

      let lastId = null;
      let current = null;
      let reverseInterval = null; // Отслеживание активного интервала обратного воспроизведения
      let isReversing = false; // Флаг для предотвращения повторных вызовов

      // ===== НАСТРОЙКИ =====
      const CONFIG = {
        // Скорость воспроизведения видео
        videoPlaybackRate: 1.3,

        // Настройки обратной перемотки
        rewindSpeed: 5.0,        // Скорость обратной перемотки (было 2.0)
        rewindInterval: 30,      // Частота обновления в мс (было 50)

        // Настройки анимаций
        fadeInDuration: 200,     // Длительность появления в мс
        fadeOutDuration: 200,    // Длительность исчезновения в мс

        // Задержки
        hideOldVideosDelay: 200, // Задержка скрытия старых видео в мс
        autoStartDelay: 100,     // Задержка автозапуска в мс
      };
      // =====================

      function pickNext () {
        // исключаем повтор предыдущего
        const pool = clips.filter(c => c.id !== lastId);
        return pool[Math.floor(Math.random() * pool.length)];
      }

      async function fadeIn (el) {
        el.style.transition = `opacity ${CONFIG.fadeInDuration}ms linear`;
        el.style.opacity = '1';
        return new Promise(resolve => setTimeout(resolve, CONFIG.fadeInDuration));
      }
      async function fadeOut (el) {
        el.style.transition = `opacity ${CONFIG.fadeOutDuration}ms linear`;
        el.style.opacity = '0';
        return new Promise(resolve => setTimeout(resolve, CONFIG.fadeOutDuration));
      }

      function showPoster () { poster.style.opacity = '1'; }
      function hidePoster () { poster.style.opacity = '0'; }

      function showOverlayFor (id) {
        if (id === 'paper' && msg) { overlay.style.opacity = '1'; }
      }
      function hideOverlay () { overlay.style.opacity = '0'; }

      function stopAll () {
        // Очищаем интервал обратного воспроизведения если он активен
        if (reverseInterval) {
          clearInterval(reverseInterval);
          reverseInterval = null;
        }
        isReversing = false;

        for (const c of clips) { c.el.pause(); c.el.currentTime = 0; c.el.style.opacity = '0'; }
      }

      function onEnded () {
        // Застываем на последнем кадре и включаем кнопки
        hideOverlay();
        rewindBtn.disabled = false; // Разблокируем кнопку перемотки
        againBtn.disabled = false;  // Разблокируем кнопку "Ещё раз"
      }

      async function rewindToStart () {
        // Предотвращаем повторные вызовы во время обратного воспроизведения
        if (isReversing) {
          return;
        }

        // Блокируем кнопки сразу при клике
        rewindBtn.disabled = true;
        againBtn.disabled = true;

        if (current && current.el.currentTime > 0) {
          // Очищаем предыдущий интервал если он существует
          if (reverseInterval) {
            clearInterval(reverseInterval);
            reverseInterval = null;
          }

          isReversing = true;

          // Проигрываем текущее видео назад до начала
          await new Promise(resolve => {
            const video = current.el;
            const reverseSpeed = CONFIG.rewindSpeed;
            const interval = CONFIG.rewindInterval;

            reverseInterval = setInterval(() => {
              const newTime = video.currentTime - (interval / 1000) * reverseSpeed;

              if (newTime <= 0) {
                clearInterval(reverseInterval);
                reverseInterval = null;
                video.currentTime = 0;
                video.pause();

                // НЕ скрываем видео - оставляем первый кадр видимым
                current = null;
                isReversing = false;
                rewindBtn.disabled = false; // Разблокируем кнопку перемотки
                againBtn.disabled = false;  // Разблокируем кнопку "Ещё раз"
                resolve();
              } else {
                video.currentTime = newTime;
              }
            }, interval);
          });
        } else {
          // Если видео уже в начале или нет текущего видео
          rewindBtn.disabled = false;
          againBtn.disabled = false;
        }
      }

      async function playNext () {
        // Предотвращаем повторные вызовы во время обратного воспроизведения
        if (isReversing) {
          return;
        }

        // Блокируем кнопки сразу при клике
        rewindBtn.disabled = true;
        againBtn.disabled = true;

        if (current && current.el.currentTime > 0) {
          // Очищаем предыдущий интервал если он существует
          if (reverseInterval) {
            clearInterval(reverseInterval);
            reverseInterval = null;
          }

          isReversing = true;

          // Если есть текущее видео и оно не в начале, проигрываем его назад
          await new Promise(resolve => {
            const video = current.el;
            const reverseSpeed = CONFIG.rewindSpeed;
            const interval = CONFIG.rewindInterval;

            reverseInterval = setInterval(() => {
              const newTime = video.currentTime - (interval / 1000) * reverseSpeed;

              if (newTime <= 0) {
                clearInterval(reverseInterval);
                reverseInterval = null;
                video.currentTime = 0;
                video.pause();

                // НЕ скрываем видео - оставляем видимым до показа нового
                current = null;
                isReversing = false;
                resolve();
              } else {
                video.currentTime = newTime;
              }
            }, interval);
          });
        }

        const next = pickNext();
        lastId = next.id;
        current = next;

        const videoToPlay = next.el;
        videoToPlay.playbackRate = CONFIG.videoPlaybackRate;
        videoToPlay.currentTime = 0;

        // Добавляем обработчик ended с автоматическим удалением
        const onPlayEnd = () => {
          onEnded();
        };
        videoToPlay.addEventListener('ended', onPlayEnd, { once: true });

        // Убираем постер для плавного перехода между видео
        hidePoster();

        try {
          // Ждем готовности видео перед показом
          if (videoToPlay.readyState < 3) { // HAVE_FUTURE_DATA
            await new Promise(resolve => {
              const onCanPlay = () => {
                videoToPlay.removeEventListener('canplay', onCanPlay);
                resolve();
              };
              videoToPlay.addEventListener('canplay', onCanPlay);
            });
          }

          // Запускаем воспроизведение нового видео
          await videoToPlay.play();

          // Показываем новое видео только после начала воспроизведения
          videoToPlay.style.opacity = '1';
          showOverlayFor(next.id);

          // Задержка чтобы новое видео точно показало первый кадр
          setTimeout(() => {
            // Только после запуска нового видео скрываем остальные
            clips.forEach(c => {
              if (c.id !== next.id) {
                c.el.pause();
                c.el.currentTime = 0;
                c.el.style.opacity = '0';
              }
            });
          }, CONFIG.hideOldVideosDelay);

        } catch (e) {
          console.error("Ошибка воспроизведения:", e);
          rewindBtn.disabled = false; // Разблокируем кнопку перемотки в случае ошибки
          againBtn.disabled = false;  // Разблокируем кнопку "Ещё раз" в случае ошибки
        }
      }

      rewindBtn.addEventListener('click', () => {
        // Дополнительная защита от множественных кликов
        if (rewindBtn.disabled || isReversing) {
          return;
        }
        rewindToStart();
      });

      againBtn.addEventListener('click', () => {
        // Дополнительная защита от множественных кликов
        if (againBtn.disabled || isReversing) {
          return;
        }
        playNext();
      });

      // Функция ожидания загрузки всех ассетов с отслеживанием прогресса
      async function waitForAssets () {
        let totalSize = 0; // Общий размер всех файлов в байтах
        let loadedSize = 0; // Загруженный размер в байтах
        let loadedAssets = 0; // Количество загруженных ассетов
        let assetSizes = {}; // Размеры каждого ассета
        let assetLoadedSizes = {}; // Загруженные размеры каждого ассета
        let animationFrameId = null; // ID для requestAnimationFrame

        // Инициализируем размеры ассетов с реалистичными оценками
        // Постер: ~750KB (из Network tab)
        assetSizes.poster = 750 * 1024;
        assetLoadedSizes.poster = 0;
        totalSize += assetSizes.poster;

        // Видео: ~1.6MB каждое (из Network tab)
        clips.forEach(clip => {
          assetSizes[clip.id] = 1600 * 1024; // 1.6MB
          assetLoadedSizes[clip.id] = 0;
          totalSize += assetSizes[clip.id];
        });

        console.log('Initial sizes:', {
          totalSize: Math.round(totalSize / 1024) + 'KB',
          poster: Math.round(assetSizes.poster / 1024) + 'KB',
          videos: clips.map(c => `${c.id}: ${Math.round(assetSizes[c.id] / 1024)}KB`)
        });

        // Функция обновления UI (вызывается каждый кадр)
        function updateUI () {
          const progress = totalSize > 0 ? (loadedSize / totalSize) * 100 : 0;

          progressBar.style.width = `${progress}%`;
          loadingText.textContent = `Загрузка... ${Math.round(progress)}%`;

          // Логирование для отладки
          console.log('Progress update:', {
            totalSize: Math.round(totalSize / 1024) + 'KB',
            loadedSize: Math.round(loadedSize / 1024) + 'KB',
            progress: Math.round(progress) + '%',
            assetSizes,
            assetLoadedSizes
          });
        }

        // Функция запуска анимации обновления UI
        function startUIAnimation () {
          if (animationFrameId) return;

          function animate () {
            updateUI();
            animationFrameId = requestAnimationFrame(animate);
          }
          animate();
        }

        // Функция остановки анимации
        function stopUIAnimation () {
          if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
          }
        }

        // Запускаем анимацию UI
        startUIAnimation();

        const assets = [
          // Ждем загрузки постера
          new Promise((resolve) => {
            const onLoad = () => {
              // Постер загружен полностью
              assetLoadedSizes.poster = assetSizes.poster;
              loadedSize += assetSizes.poster;
              loadedAssets++;

              console.log(`Poster loaded: ${Math.round(assetSizes.poster / 1024)}KB`);
              resolve();
            };

            if (poster.complete) {
              onLoad();
            } else {
              poster.addEventListener('load', onLoad, { once: true });
              poster.addEventListener('error', onLoad, { once: true });
            }
          }),
          // Ждем ПОЛНОЙ загрузки всех видео
          ...clips.map((clip, index) =>
            new Promise((resolve) => {
              const video = clip.el;
              let isResolved = false; // Предотвращаем двойное разрешение
              let videoSize = 0; // Размер видеофайла

              // Функция для обновления прогресса видео
              const updateVideoProgress = () => {
                if (video.buffered.length > 0 && video.duration > 0) {
                  const bufferedEnd = video.buffered.end(video.buffered.length - 1);
                  const progress = (bufferedEnd / video.duration) * 100;

                  // Используем предустановленный размер видео
                  videoSize = assetSizes[clip.id];

                  // Обновляем загруженный размер
                  const loadedBytes = (progress / 100) * videoSize;
                  const previousLoaded = assetLoadedSizes[clip.id];
                  const newLoaded = loadedBytes - previousLoaded;

                  if (newLoaded > 0) {
                    assetLoadedSizes[clip.id] = loadedBytes;
                    loadedSize += newLoaded;
                  }

                  console.log(`Video ${clip.id} progress:`, {
                    bufferedEnd,
                    duration: video.duration,
                    progress: Math.round(progress),
                    loadedBytes: Math.round(loadedBytes / 1024) + 'KB',
                    videoSize: Math.round(videoSize / 1024) + 'KB',
                    readyState: video.readyState,
                    totalLoaded: Math.round(loadedSize / 1024) + 'KB',
                    totalSize: Math.round(totalSize / 1024) + 'KB'
                  });
                }
              };

              // Функция проверки готовности видео
              const checkVideoReady = () => {
                if (isResolved) return;

                // Проверяем что видео готово к воспроизведению до конца
                const isReady = video.readyState >= 4 && // HAVE_ENOUGH_DATA
                  video.buffered.length > 0 &&
                  video.duration > 0 &&
                  video.buffered.end(video.buffered.length - 1) >= video.duration * 0.95; // 95% загружено

                console.log(`Video ${clip.id} ready check:`, {
                  readyState: video.readyState,
                  bufferedEnd: video.buffered.length > 0 ? video.buffered.end(video.buffered.length - 1) : 0,
                  duration: video.duration,
                  isReady,
                  loadedBytes: Math.round(assetLoadedSizes[clip.id] / 1024) + 'KB'
                });

                if (isReady) {
                  isResolved = true;

                  // Убеждаемся что видео помечено как полностью загруженное
                  const finalLoadedBytes = assetSizes[clip.id];
                  const previousLoaded = assetLoadedSizes[clip.id];
                  const remainingBytes = finalLoadedBytes - previousLoaded;

                  if (remainingBytes > 0) {
                    assetLoadedSizes[clip.id] = finalLoadedBytes;
                    loadedSize += remainingBytes;
                  }

                  loadedAssets++;

                  // Убираем все слушатели
                  video.removeEventListener('progress', updateVideoProgress);
                  video.removeEventListener('loadeddata', updateVideoProgress);
                  video.removeEventListener('canplaythrough', checkVideoReady);
                  video.removeEventListener('error', onError);

                  console.log(`Video ${clip.id} completed - fully loaded (${Math.round(finalLoadedBytes / 1024)}KB)`);
                  resolve();
                }
              };

              const onError = () => {
                if (isResolved) return;
                isResolved = true;

                // Считаем ошибку как завершенную
                const finalLoadedBytes = assetSizes[clip.id];
                const previousLoaded = assetLoadedSizes[clip.id];
                const remainingBytes = finalLoadedBytes - previousLoaded;

                if (remainingBytes > 0) {
                  assetLoadedSizes[clip.id] = finalLoadedBytes;
                  loadedSize += remainingBytes;
                }

                loadedAssets++;

                // Убираем все слушатели
                video.removeEventListener('progress', updateVideoProgress);
                video.removeEventListener('loadeddata', updateVideoProgress);
                video.removeEventListener('canplaythrough', checkVideoReady);
                video.removeEventListener('error', onError);

                console.log(`Video ${clip.id} error, treating as completed`);
                resolve(); // Продолжаем даже при ошибке
              };

              // Отслеживаем прогресс загрузки
              video.addEventListener('progress', updateVideoProgress);
              video.addEventListener('loadeddata', updateVideoProgress);
              video.addEventListener('canplaythrough', checkVideoReady);
              video.addEventListener('error', onError);

              // Проверяем готовность при каждом обновлении прогресса
              video.addEventListener('progress', checkVideoReady);
              video.addEventListener('loadeddata', checkVideoReady);

              // Таймаут на случай если видео не загрузится за разумное время
              const timeout = setTimeout(() => {
                if (!isResolved) {
                  console.warn(`Video ${clip.id} timeout, forcing completion`);
                  checkVideoReady(); // Принудительно завершаем
                }
              }, 30000); // 30 секунд таймаут

              // Очищаем таймаут при завершении
              const originalResolve = resolve;
              resolve = () => {
                clearTimeout(timeout);
                originalResolve();
              };

              // Если видео уже готово
              if (video.readyState >= 4) {
                checkVideoReady();
              }
            })
          )
        ];

        try {
          await Promise.all(assets);

          // Останавливаем анимацию UI
          stopUIAnimation();

          // Дополнительная проверка что все видео действительно готовы
          const allVideosReady = clips.every(clip => {
            const video = clip.el;
            return video.readyState >= 4 &&
              video.buffered.length > 0 &&
              video.duration > 0 &&
              video.buffered.end(video.buffered.length - 1) >= video.duration * 0.9;
          });

          if (allVideosReady) {
            console.log('Все ассеты загружены и готовы к воспроизведению');
            console.log(`Общий размер: ${Math.round(totalSize / 1024)}KB, Загружено: ${Math.round(loadedSize / 1024)}KB`);
          } else {
            console.warn('Некоторые видео могут быть не полностью загружены');
          }

          // Убеждаемся что прогресс показывает 100%
          progressBar.style.width = '100%';
          loadingText.textContent = 'Готово!';

          // Показываем экран запуска после небольшой задержки
          setTimeout(() => {
            loadingIndicator.style.display = 'none';
            stage.classList.remove('loading');

            // Проверяем что постер загружен
            const startPoster = document.getElementById('startPoster');
            const startBtn = document.getElementById('startBtn');
            console.log('Start poster loaded:', startPoster.complete, startPoster.naturalWidth, startPoster.naturalHeight);
            console.log('Start button found:', startBtn, 'visible:', getComputedStyle(startBtn).visibility, 'opacity:', getComputedStyle(startBtn).opacity);

            // Если постер не загружен, ждем его загрузки
            if (!startPoster.complete) {
              startPoster.addEventListener('load', () => {
                console.log('Start poster loaded after wait');
                startScreen.classList.add('visible');
              });
              startPoster.addEventListener('error', () => {
                console.warn('Start poster failed to load');
                startScreen.classList.add('visible'); // Показываем экран даже без постера
              });
            } else {
              startScreen.classList.add('visible');
            }
          }, 500);

        } catch (error) {
          console.warn('Ошибка при загрузке ассетов:', error);
          stopUIAnimation();
        }
      }

      // Функция запуска приложения
      function startApplication () {
        startScreen.classList.remove('visible');
        showPoster(); // Показываем постер после загрузки
        setTimeout(playNext, CONFIG.autoStartDelay);
      }

      // Обработчик клика кнопки "Начать"
      startBtn.addEventListener('click', startApplication);

      // Загрузка ассетов при входе
      (async () => {
        await waitForAssets();
      })();

    })();
  </script>
</body>

</html>
