<!doctype html>
<html lang="ru">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Baku Card</title>
  <meta name="description" content="Открытка с плюшевым мишкой Baku: букет, лист с поздравлением, сердечко." />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Baku Card" />
  <meta property="og:description" content="Открытка с плюшевым мишкой Baku: букет, лист с поздравлением, сердечко." />
  <meta property="og:image" content="poster.png" />
  <meta name="theme-color" content="#ffffff" />

  <!-- Preload poster and videos for snappy playback -->
  <link rel="preload" as="image" href="poster.png" fetchpriority="high" />
  <link rel="preload" as="video" href="bouquet.mp4" type="video/mp4" />
  <link rel="preload" as="video" href="paper.mp4" type="video/mp4" />
  <link rel="preload" as="video" href="heart.mp4" type="video/mp4" />

  <style>
    :root {
      --bg: #f8f8f8;
      --fg: #0f0f0f;
      --btn: #111;
      --btn-fg: #fff;
      --accent: #ff85a1;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, "Noto Sans", Arial, sans-serif;
      -webkit-font-smoothing: antialiased;
      text-rendering: optimizeLegibility;
      display: grid;
      place-items: center;
      gap: 16px;
    }

    .wrap {
      width: min(100vw, 480px);
      padding: env(safe-area-inset-top) 12px env(safe-area-inset-bottom);
    }

    .stage {
      position: relative;
      width: 100%;
      aspect-ratio: 9/16;
      border-radius: 16px;
      overflow: hidden;
      background: #000;
      box-shadow: 0 10px 40px rgba(0, 0, 0, .15);
    }

    .poster,
    video {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .poster {
      opacity: 0;
      transition: opacity 250ms linear;
    }

    video {
      opacity: 0;
      transition: opacity 200ms linear;
    }

    .overlayText {
      position: absolute;
      left: 50%;
      top: 63%;
      transform: translate(-50%, -50%);
      width: 72%;
      padding: 10px 12px;
      text-align: center;
      background: rgba(255, 255, 255, 0.85);
      border-radius: 8px;
      font-size: clamp(14px, 2.6vw, 20px);
      line-height: 1.25;
      font-weight: 600;
      color: #222;
      text-wrap: balance;
      filter: drop-shadow(0 2px 6px rgba(0, 0, 0, .2));
      opacity: 0;
      transition: opacity 180ms ease-out;
      /* Tip: при необходимости сдвинь положение под свой клип */
    }

    .controls {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-top: 12px;
    }

    button {
      -webkit-tap-highlight-color: transparent;
      cursor: pointer;
      border: 0;
      border-radius: 999px;
      padding: 12px 18px;
      font-size: 16px;
      font-weight: 600;
      background: var(--btn);
      color: var(--btn-fg);
      box-shadow: 0 6px 18px rgba(0, 0, 0, .12);
      transition: all 200ms ease;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: scale(0.95);
    }

    .hint {
      text-align: center;
      font-size: 12px;
      opacity: .6;
      margin-top: 8px;
    }

    .loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      color: white;
      font-size: 18px;
      font-weight: 600;
      z-index: 10;
    }

    .loading-progress {
      width: 200px;
      height: 6px;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 3px;
      overflow: hidden;
      margin: 0 auto 16px;
      position: relative;
    }

    .loading-progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #ff85a1, #ff6b9d);
      border-radius: 3px;
      width: 0%;
      transition: width 0.3s ease;
      position: relative;
    }

    .loading-progress-bar::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
      animation: shimmer 1.5s infinite;
    }

    @keyframes shimmer {
      0% {
        transform: translateX(-100%);
      }

      100% {
        transform: translateX(100%);
      }
    }

    .loading-text {
      font-size: 14px;
      opacity: 0.9;
    }

    .stage.loading .poster,
    .stage.loading video {
      opacity: 0;
    }

    .start-screen {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 20;
      opacity: 0;
      transition: opacity 0.5s ease;
    }

    .start-screen.visible {
      opacity: 1;
    }

    .start-screen .poster {
      border-radius: 12px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
      margin-bottom: 32px;
      opacity: 1 !important;
      /* Принудительно показываем постер на экране запуска */
      background: #333;
      /* Fallback фон если изображение не загрузится */
      min-height: 200px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 14px;
    }

    .start-btn {
      background: transparent;
      /* Временный яркий фон для отладки */
      border: 2px solid white;
      color: white;
      font-size: 18px;
      font-weight: 600;
      padding: 16px 32px;
      border-radius: 999px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
      position: relative;
      z-index: 21;
      opacity: 1 !important;
      visibility: visible !important;
      display: block !important;
      min-width: 120px;
      min-height: 50px;
    }

    .start-btn:hover {
      background: #ff85a263;
      color: white;
      box-shadow: 0 8px 24px rgba(255, 133, 161, 0.4);
    }

    .start-btn:active {
      transform: translateY(0);
    }

    /* Система тостов для ошибок */
    .toast-container {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      z-index: 1000;
      pointer-events: none;
    }

    .toast {
      background: rgba(220, 38, 38, 0.95);
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      font-size: 14px;
      font-weight: 500;
      margin-bottom: 8px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      opacity: 0;
      transform: translateY(-20px);
      transition: all 0.3s ease;
      pointer-events: auto;
      max-width: 90vw;
      text-align: center;
      word-wrap: break-word;
    }

    .toast.show {
      opacity: 1;
      transform: translateY(0);
    }

    .toast.hide {
      opacity: 0;
      transform: translateY(-20px);
    }

    .toast.warning {
      background: rgba(245, 158, 11, 0.95);
    }

    .toast.info {
      background: rgba(59, 130, 246, 0.95);
    }

    .toast.success {
      background: rgba(34, 197, 94, 0.95);
    }

    .toast-close {
      background: none;
      border: none;
      color: white;
      font-size: 18px;
      cursor: pointer;
      margin-left: 12px;
      padding: 0;
      opacity: 0.7;
      transition: opacity 0.2s ease;
    }

    .toast-close:hover {
      opacity: 1;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="stage loading" id="stage">
      <!-- Индикатор загрузки -->
      <div class="loading" id="loadingIndicator">
        <div class="loading-progress">
          <div class="loading-progress-bar" id="progressBar"></div>
        </div>
        <div class="loading-text" id="loadingText">Загрузка...</div>
      </div>

      <img id="poster" class="poster" src="poster.png" alt="Baku poster" />

      <!-- Видеодорожки. MP4 обязателен для iOS -->
      <video id="v-bouquet" playsinline webkit-playsinline muted preload="auto" poster="poster.png"></video>
      <video id="v-paper" playsinline webkit-playsinline muted preload="auto" poster="poster.png"></video>
      <video id="v-heart" playsinline webkit-playsinline muted preload="auto" poster="poster.png"></video>

      <!-- Надпись поверх листа (показывается только во время клипа paper) -->
      <div id="overlayText" class="overlayText"></div>

      <!-- Экран запуска -->
      <div id="startScreen" class="start-screen">
        <img id="startPoster" class="poster" src="poster.png" alt="Baku poster" />
        <button id="startBtn" class="start-btn">Начать</button>
      </div>
    </div>

    <div class="controls">
      <button id="rewindBtn">На начало</button>
      <button id="againBtn">Ещё раз</button>
    </div>
    <div class="hint" id="hint">Автовоспроизведение без звука поддерживается на большинстве устройств</div>
  </div>

  <!-- Контейнер для тостов -->
  <div id="toastContainer" class="toast-container"></div>

  <script>
    (function () {
      const qs = new URLSearchParams(location.search);
      const lang = qs.get('lang') || 'ru';
      const msg = qs.get('msg') || '';

      const STR = {
        ru: { again: 'Ещё раз', rewind: 'На начало', hint: 'Автовоспроизведение без звука поддерживается на большинстве устройств' },
        en: { again: 'Again', rewind: 'Rewind', hint: 'Autoplay without sound works on most devices' }
      };

      // UI i18n
      document.getElementById('rewindBtn').textContent = (STR[lang] || STR.ru).rewind;
      document.getElementById('againBtn').textContent = (STR[lang] || STR.ru).again;
      document.getElementById('hint').textContent = (STR[lang] || STR.ru).hint;

      // Map клипов
      const clips = [
        { id: 'bouquet', el: document.getElementById('v-bouquet'), src: 'bouquet.mp4', weight: 1 },
        { id: 'paper', el: document.getElementById('v-paper'), src: 'paper.mp4', weight: 1 },
        { id: 'heart', el: document.getElementById('v-heart'), src: 'heart.mp4', weight: 1 }
      ];

      // Поддержка WebM (не для iOS). Если рядом лежат webm — можно указать.
      const webmAlt = {
        // bouquet: 'bouquet.webm',
        // paper: 'paper.webm',
        // heart: 'heart.webm'
      };

      // Инициализация источников сразу для iOS совместимости
      for (const c of clips) {
        const canWebm = !!document.createElement('video').canPlayType('video/webm; codecs="vp9,vorbis"');
        const preferred = (canWebm && webmAlt[c.id]) ? webmAlt[c.id] : c.src;
        const source = document.createElement('source');
        source.src = preferred;
        c.el.appendChild(source);
        c.el.muted = true;
        c.el.playsInline = true;
        c.el.setAttribute('playsinline', '');
        c.el.setAttribute('webkit-playsinline', ''); // Дополнительная поддержка для старых iOS
        c.el.preload = 'auto'; // Принудительная предзагрузка
        // Обработчик ended будет добавляться динамически в playNext()
        c.el.addEventListener('error', (e) => {
          console.warn('Video error', c.id, e);
          ErrorHandler.handleCriticalError(e, `Видео ${c.id}`);
        });
      }

      const poster = document.getElementById('poster');
      const overlay = document.getElementById('overlayText');
      const rewindBtn = document.getElementById('rewindBtn');
      const againBtn = document.getElementById('againBtn');
      const stage = document.getElementById('stage');
      const loadingIndicator = document.getElementById('loadingIndicator');
      const progressBar = document.getElementById('progressBar');
      const loadingText = document.getElementById('loadingText');
      const startScreen = document.getElementById('startScreen');
      const startBtn = document.getElementById('startBtn');
      const toastContainer = document.getElementById('toastContainer');

      // Рендер текста для клипа paper
      overlay.textContent = msg;
      overlay.style.display = msg ? 'block' : 'none';

      let lastId = null;
      let current = null;
      let reverseInterval = null; // Отслеживание активного интервала обратного воспроизведения
      let isReversing = false; // Флаг для предотвращения повторных вызовов

      // ===== СИСТЕМА ОБРАБОТКИ ОШИБОК =====
      const ErrorHandler = {
        // Типы ошибок
        TYPES: {
          CRITICAL: 'critical',
          WARNING: 'warning',
          INFO: 'info',
          SUCCESS: 'success'
        },

        // Показ тоста
        showToast (message, type = 'critical', duration = 5000) {
          const toast = document.createElement('div');
          toast.className = `toast ${type}`;

          const closeBtn = document.createElement('button');
          closeBtn.className = 'toast-close';
          closeBtn.innerHTML = '×';
          closeBtn.onclick = () => this.hideToast(toast);

          toast.innerHTML = message;
          toast.appendChild(closeBtn);

          toastContainer.appendChild(toast);

          // Анимация появления
          setTimeout(() => toast.classList.add('show'), 10);

          // Автоматическое скрытие
          if (duration > 0) {
            setTimeout(() => this.hideToast(toast), duration);
          }

          return toast;
        },

        // Скрытие тоста
        hideToast (toast) {
          toast.classList.remove('show');
          toast.classList.add('hide');
          setTimeout(() => {
            if (toast.parentNode) {
              toast.parentNode.removeChild(toast);
            }
          }, 300);
        },

        // Обработка критических ошибок
        handleCriticalError (error, context = '') {
          console.error('КРИТИЧЕСКАЯ ОШИБКА:', error, context);

          let message = 'Произошла критическая ошибка';

          if (error.name === 'NotAllowedError') {
            message = 'Воспроизведение заблокировано браузером. Попробуйте нажать "Ещё раз"';
          } else if (error.name === 'NotSupportedError') {
            message = 'Формат видео не поддерживается';
          } else if (error.message) {
            message = `Ошибка: ${error.message}`;
          }

          if (context) {
            message += ` (${context})`;
          }

          this.showToast(message, this.TYPES.CRITICAL, 8000);
        },

        // Обработка предупреждений
        handleWarning (message, context = '') {
          console.warn('ПРЕДУПРЕЖДЕНИЕ:', message, context);
          this.showToast(`⚠️ ${message}`, this.TYPES.WARNING, 4000);
        },

        // Обработка информационных сообщений
        handleInfo (message, context = '') {
          console.info('ИНФО:', message, context);
          this.showToast(`ℹ️ ${message}`, this.TYPES.INFO, 3000);
        },

        // Обработка успешных операций
        handleSuccess (message, context = '') {
          console.log('УСПЕХ:', message, context);
          this.showToast(`✅ ${message}`, this.TYPES.SUCCESS, 2000);
        }
      };

      // Глобальный обработчик необработанных ошибок
      window.addEventListener('error', (event) => {
        ErrorHandler.handleCriticalError(event.error || new Error(event.message), 'Глобальная ошибка');
      });

      // Обработчик необработанных промисов
      window.addEventListener('unhandledrejection', (event) => {
        ErrorHandler.handleCriticalError(new Error(event.reason), 'Необработанный промис');
      });
      // =====================================

      // ===== НАСТРОЙКИ =====
      const CONFIG = {
        // Скорость воспроизведения видео
        videoPlaybackRate: 1.3,

        // Настройки обратной перемотки
        rewindSpeed: 5.0,        // Скорость обратной перемотки (было 2.0)
        rewindInterval: 30,      // Частота обновления в мс (было 50)

        // Настройки анимаций
        fadeInDuration: 200,     // Длительность появления в мс
        fadeOutDuration: 200,    // Длительность исчезновения в мс

        // Задержки
        hideOldVideosDelay: 200, // Задержка скрытия старых видео в мс
        autoStartDelay: 100,     // Задержка автозапуска в мс
      };
      // =====================

      function pickNext () {
        // исключаем повтор предыдущего
        const pool = clips.filter(c => c.id !== lastId);
        return pool[Math.floor(Math.random() * pool.length)];
      }

      async function fadeIn (el) {
        el.style.transition = `opacity ${CONFIG.fadeInDuration}ms linear`;
        el.style.opacity = '1';
        return new Promise(resolve => setTimeout(resolve, CONFIG.fadeInDuration));
      }
      async function fadeOut (el) {
        el.style.transition = `opacity ${CONFIG.fadeOutDuration}ms linear`;
        el.style.opacity = '0';
        return new Promise(resolve => setTimeout(resolve, CONFIG.fadeOutDuration));
      }

      function showPoster () { poster.style.opacity = '1'; }
      function hidePoster () { poster.style.opacity = '0'; }

      function showOverlayFor (id) {
        if (id === 'paper' && msg) { overlay.style.opacity = '1'; }
      }
      function hideOverlay () { overlay.style.opacity = '0'; }

      function stopAll () {
        // Очищаем интервал обратного воспроизведения если он активен
        if (reverseInterval) {
          clearInterval(reverseInterval);
          reverseInterval = null;
        }
        isReversing = false;

        for (const c of clips) { c.el.pause(); c.el.currentTime = 0; c.el.style.opacity = '0'; }
      }

      function onEnded () {
        // Застываем на последнем кадре и включаем кнопки
        hideOverlay();
        rewindBtn.disabled = false; // Разблокируем кнопку перемотки
        againBtn.disabled = false;  // Разблокируем кнопку "Ещё раз"
      }

      async function rewindToStart () {
        // Предотвращаем повторные вызовы во время обратного воспроизведения
        if (isReversing) {
          return;
        }

        // Блокируем кнопки сразу при клике
        rewindBtn.disabled = true;
        againBtn.disabled = true;

        if (current && current.el.currentTime > 0) {
          // Очищаем предыдущий интервал если он существует
          if (reverseInterval) {
            clearInterval(reverseInterval);
            reverseInterval = null;
          }

          isReversing = true;

          // Проигрываем текущее видео назад до начала
          await new Promise(resolve => {
            const video = current.el;
            const reverseSpeed = CONFIG.rewindSpeed;
            const interval = CONFIG.rewindInterval;

            reverseInterval = setInterval(() => {
              const newTime = video.currentTime - (interval / 1000) * reverseSpeed;

              if (newTime <= 0) {
                clearInterval(reverseInterval);
                reverseInterval = null;
                video.currentTime = 0;
                video.pause();

                // НЕ скрываем видео - оставляем первый кадр видимым
                current = null;
                isReversing = false;
                rewindBtn.disabled = false; // Разблокируем кнопку перемотки
                againBtn.disabled = false;  // Разблокируем кнопку "Ещё раз"
                resolve();
              } else {
                video.currentTime = newTime;
              }
            }, interval);
          });
        } else {
          // Если видео уже в начале или нет текущего видео
          rewindBtn.disabled = false;
          againBtn.disabled = false;
        }
      }

      async function playNext () {
        // Предотвращаем повторные вызовы во время обратного воспроизведения
        if (isReversing) {
          return;
        }

        // Блокируем кнопки сразу при клике
        rewindBtn.disabled = true;
        againBtn.disabled = true;

        if (current && current.el.currentTime > 0) {
          // Очищаем предыдущий интервал если он существует
          if (reverseInterval) {
            clearInterval(reverseInterval);
            reverseInterval = null;
          }

          isReversing = true;

          // Если есть текущее видео и оно не в начале, проигрываем его назад
          await new Promise(resolve => {
            const video = current.el;
            const reverseSpeed = CONFIG.rewindSpeed;
            const interval = CONFIG.rewindInterval;

            reverseInterval = setInterval(() => {
              const newTime = video.currentTime - (interval / 1000) * reverseSpeed;

              if (newTime <= 0) {
                clearInterval(reverseInterval);
                reverseInterval = null;
                video.currentTime = 0;
                video.pause();

                // НЕ скрываем видео - оставляем видимым до показа нового
                current = null;
                isReversing = false;
                resolve();
              } else {
                video.currentTime = newTime;
              }
            }, interval);
          });
        }

        const next = pickNext();
        lastId = next.id;
        current = next;

        const videoToPlay = next.el;
        videoToPlay.playbackRate = CONFIG.videoPlaybackRate;
        videoToPlay.currentTime = 0;

        // Добавляем обработчик ended с автоматическим удалением
        const onPlayEnd = () => {
          onEnded();
        };
        videoToPlay.addEventListener('ended', onPlayEnd, { once: true });

        // Убираем постер для плавного перехода между видео
        hidePoster();

        try {
          // Для iOS: показываем видео сразу, чтобы избежать черного экрана
          videoToPlay.style.opacity = '1';
          showOverlayFor(next.id);

          // Ждем готовности видео перед воспроизведением
          if (videoToPlay.readyState < 3) { // HAVE_FUTURE_DATA
            await new Promise(resolve => {
              const onCanPlay = () => {
                videoToPlay.removeEventListener('canplay', onCanPlay);
                resolve();
              };
              videoToPlay.addEventListener('canplay', onCanPlay);
            });
          }

          // Запускаем воспроизведение нового видео
          await videoToPlay.play();

          // Задержка чтобы новое видео точно показало первый кадр
          setTimeout(() => {
            // Только после запуска нового видео скрываем остальные
            clips.forEach(c => {
              if (c.id !== next.id) {
                c.el.pause();
                c.el.currentTime = 0;
                c.el.style.opacity = '0';
              }
            });
          }, CONFIG.hideOldVideosDelay);

        } catch (e) {
          console.error("Ошибка воспроизведения:", e);

          // Обрабатываем ошибку через централизованную систему
          ErrorHandler.handleCriticalError(e, `Воспроизведение видео ${next.id}`);

          // Для iOS: если воспроизведение не удалось, показываем постер
          const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
          if (isIOS) {
            console.log("iOS: Fallback to poster due to playback error");
            showPoster();
            videoToPlay.style.opacity = '0';
            ErrorHandler.handleInfo("Переключение на постер из-за ошибки воспроизведения", "iOS fallback");
          }

          rewindBtn.disabled = false; // Разблокируем кнопку перемотки в случае ошибки
          againBtn.disabled = false;  // Разблокируем кнопку "Ещё раз" в случае ошибки
        }
      }

      rewindBtn.addEventListener('click', () => {
        // Дополнительная защита от множественных кликов
        if (rewindBtn.disabled || isReversing) {
          return;
        }
        rewindToStart();
      });

      againBtn.addEventListener('click', () => {
        // Дополнительная защита от множественных кликов
        if (againBtn.disabled || isReversing) {
          return;
        }
        playNext();
      });

      // Функция ожидания загрузки всех ассетов с отслеживанием прогресса
      async function waitForAssets () {
        let totalAssets = 0; // Общее количество ассетов
        let loadedAssets = 0; // Количество загруженных ассетов
        let animationFrameId = null; // ID для requestAnimationFrame
        let progressAnimationId = null; // ID для анимации прогресса
        let isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        let startTime = Date.now();
        let maxLoadTime = 30000; // Максимальное время загрузки 30 секунд

        // Подсчитываем общее количество ассетов
        totalAssets = 1 + clips.length; // постер + видео

        console.log('Loading assets:', {
          totalAssets,
          isIOS,
          clips: clips.map(c => c.id)
        });

        // Функция обновления UI с плавной анимацией
        function updateUI (forceProgress = null) {
          let progress;

          if (forceProgress !== null) {
            progress = forceProgress;
          } else {
            // Базовый прогресс на основе количества загруженных ассетов
            const baseProgress = (loadedAssets / totalAssets) * 80; // 80% за загруженные ассеты

            // Дополнительный прогресс на основе времени (для iOS fallback)
            const timeProgress = Math.min(20, (Date.now() - startTime) / (maxLoadTime * 0.8) * 20);

            progress = Math.min(95, baseProgress + timeProgress);
          }

          progressBar.style.width = `${progress}%`;
          loadingText.textContent = `Загрузка... ${Math.round(progress)}%`;

          // Логирование для отладки
          console.log('Progress update:', {
            loadedAssets,
            totalAssets,
            progress: Math.round(progress) + '%',
            isIOS,
            timeElapsed: Math.round((Date.now() - startTime) / 1000) + 's'
          });
        }

        // Функция запуска анимации обновления UI
        function startUIAnimation () {
          if (animationFrameId) return;

          function animate () {
            updateUI();
            animationFrameId = requestAnimationFrame(animate);
          }
          animate();
        }

        // Функция остановки анимации
        function stopUIAnimation () {
          if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
            animationFrameId = null;
          }
          if (progressAnimationId) {
            clearInterval(progressAnimationId);
            progressAnimationId = null;
          }
        }

        // Запускаем анимацию UI
        startUIAnimation();

        // Для iOS добавляем дополнительную анимацию прогресса
        if (isIOS) {
          progressAnimationId = setInterval(() => {
            updateUI();
          }, 100);
        }

        const assets = [
          // Ждем загрузки постера
          new Promise((resolve) => {
            const onLoad = () => {
              loadedAssets++;
              console.log(`Poster loaded (${loadedAssets}/${totalAssets})`);
              updateUI();
              resolve();
            };

            if (poster.complete) {
              onLoad();
            } else {
              poster.addEventListener('load', onLoad, { once: true });
              poster.addEventListener('error', () => {
                ErrorHandler.handleWarning('Не удалось загрузить постер', 'Загрузка изображения');
                onLoad();
              }, { once: true });
            }
          }),
          // Ждем загрузки всех видео (упрощенная логика для iOS)
          ...clips.map((clip) =>
            new Promise((resolve) => {
              const video = clip.el;
              let isResolved = false;
              let hasStartedLoading = false;

              // Функция проверки готовности видео (упрощенная для iOS)
              const checkVideoReady = () => {
                if (isResolved) return;

                let isReady = false;

                if (isIOS) {
                  // Для iOS используем более мягкие критерии
                  isReady = video.readyState >= 3 && // HAVE_FUTURE_DATA
                    video.duration > 0 &&
                    (video.buffered.length === 0 ||
                      video.buffered.end(video.buffered.length - 1) >= video.duration * 0.5); // 50% загружено
                } else {
                  // Для других браузеров используем строгие критерии
                  isReady = video.readyState >= 4 && // HAVE_ENOUGH_DATA
                    video.buffered.length > 0 &&
                    video.duration > 0 &&
                    video.buffered.end(video.buffered.length - 1) >= video.duration * 0.9; // 90% загружено
                }

                console.log(`Video ${clip.id} ready check:`, {
                  readyState: video.readyState,
                  bufferedEnd: video.buffered.length > 0 ? video.buffered.end(video.buffered.length - 1) : 0,
                  duration: video.duration,
                  isReady,
                  isIOS
                });

                if (isReady) {
                  isResolved = true;
                  loadedAssets++;
                  console.log(`Video ${clip.id} completed (${loadedAssets}/${totalAssets})`);
                  updateUI();
                  resolve();
                }
              };

              const onError = () => {
                if (isResolved) return;
                isResolved = true;
                loadedAssets++;
                console.log(`Video ${clip.id} error, treating as completed (${loadedAssets}/${totalAssets})`);
                ErrorHandler.handleWarning(`Ошибка загрузки видео ${clip.id}`, 'Загрузка видео');
                updateUI();
                resolve();
              };

              const onLoadStart = () => {
                if (!hasStartedLoading) {
                  hasStartedLoading = true;
                  console.log(`Video ${clip.id} started loading`);
                }
              };

              const onProgress = () => {
                if (!isResolved) {
                  checkVideoReady();
                }
              };

              // Добавляем слушатели событий
              video.addEventListener('loadstart', onLoadStart);
              video.addEventListener('loadeddata', checkVideoReady);
              video.addEventListener('canplay', checkVideoReady);
              video.addEventListener('canplaythrough', checkVideoReady);
              video.addEventListener('progress', onProgress);
              video.addEventListener('error', onError);

              // Таймаут для принудительного завершения
              const timeout = setTimeout(() => {
                if (!isResolved) {
                  console.warn(`Video ${clip.id} timeout, forcing completion`);
                  isResolved = true;
                  loadedAssets++;
                  updateUI();
                  resolve();
                }
              }, maxLoadTime);

              // Очищаем таймаут при завершении
              const originalResolve = resolve;
              resolve = () => {
                clearTimeout(timeout);
                video.removeEventListener('loadstart', onLoadStart);
                video.removeEventListener('loadeddata', checkVideoReady);
                video.removeEventListener('canplay', checkVideoReady);
                video.removeEventListener('canplaythrough', checkVideoReady);
                video.removeEventListener('progress', onProgress);
                video.removeEventListener('error', onError);
                originalResolve();
              };

              // Если видео уже готово
              if (video.readyState >= 3) {
                checkVideoReady();
              }
            })
          )
        ];

        try {
          await Promise.all(assets);

          // Останавливаем анимацию UI
          stopUIAnimation();

          // Финальная проверка готовности
          const allVideosReady = clips.every(clip => {
            const video = clip.el;
            if (isIOS) {
              // Для iOS более мягкие критерии
              return video.readyState >= 3 && video.duration > 0;
            } else {
              // Для других браузеров строгие критерии
              return video.readyState >= 4 &&
                video.buffered.length > 0 &&
                video.duration > 0 &&
                video.buffered.end(video.buffered.length - 1) >= video.duration * 0.8;
            }
          });

          if (allVideosReady) {
            console.log('Все ассеты загружены и готовы к воспроизведению');
            console.log(`Загружено ассетов: ${loadedAssets}/${totalAssets}`);
            ErrorHandler.handleSuccess('Все ресурсы загружены успешно', 'Инициализация');
          } else {
            console.warn('Некоторые видео могут быть не полностью загружены, но продолжаем');
            ErrorHandler.handleWarning('Некоторые видео загружены частично', 'Загрузка видео');
          }

          // Плавно доводим прогресс до 100%
          updateUI(100);
          loadingText.textContent = 'Готово!';

          // Показываем экран запуска после небольшой задержки
          setTimeout(() => {
            loadingIndicator.style.display = 'none';
            stage.classList.remove('loading');

            // Проверяем что постер загружен
            const startPoster = document.getElementById('startPoster');
            const startBtn = document.getElementById('startBtn');
            console.log('Start poster loaded:', startPoster.complete, startPoster.naturalWidth, startPoster.naturalHeight);
            console.log('Start button found:', startBtn, 'visible:', getComputedStyle(startBtn).visibility, 'opacity:', getComputedStyle(startBtn).opacity);

            // Если постер не загружен, ждем его загрузки
            if (!startPoster.complete) {
              startPoster.addEventListener('load', () => {
                console.log('Start poster loaded after wait');
                startScreen.classList.add('visible');
              });
              startPoster.addEventListener('error', () => {
                console.warn('Start poster failed to load');
                ErrorHandler.handleWarning('Не удалось загрузить постер для экрана запуска', 'Экран запуска');
                startScreen.classList.add('visible'); // Показываем экран даже без постера
              });
            } else {
              startScreen.classList.add('visible');
            }
          }, 500);

        } catch (error) {
          console.warn('Ошибка при загрузке ассетов:', error);
          ErrorHandler.handleWarning('Некоторые ресурсы не загрузились полностью', 'Загрузка ассетов');
          stopUIAnimation();

          // В случае ошибки все равно показываем интерфейс
          updateUI(100);
          loadingText.textContent = 'Готово!';

          setTimeout(() => {
            loadingIndicator.style.display = 'none';
            stage.classList.remove('loading');
            startScreen.classList.add('visible');
          }, 500);
        }
      }

      // Функция запуска приложения
      function startApplication () {
        startScreen.classList.remove('visible');
        showPoster(); // Показываем постер после загрузки

        // Для iOS: дополнительная задержка для стабилизации
        const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        const delay = isIOS ? 300 : CONFIG.autoStartDelay;

        setTimeout(playNext, delay);
      }

      // Обработчик клика кнопки "Начать"
      startBtn.addEventListener('click', startApplication);

      // Загрузка ассетов при входе
      (async () => {
        await waitForAssets();
      })();

    })();
  </script>
</body>

</html>
