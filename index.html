<!doctype html>
<html lang="ru">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Baku Card</title>
  <meta name="description" content="Открытка с плюшевым мишкой Baku: букет, лист с поздравлением, сердечко." />
  <meta property="og:type" content="website" />
  <meta property="og:title" content="Baku Card" />
  <meta property="og:description" content="Открытка с плюшевым мишкой Baku: букет, лист с поздравлением, сердечко." />
  <meta property="og:image" content="poster.jpg" />
  <meta name="theme-color" content="#ffffff" />

  <!-- Preload poster and videos for snappy playback -->
  <link rel="preload" as="image" href="poster.jpg" fetchpriority="high" />
  <link rel="preload" as="video" href="bouquet.mp4" type="video/mp4" />
  <link rel="preload" as="video" href="paper.mp4" type="video/mp4" />
  <link rel="preload" as="video" href="heart.mp4" type="video/mp4" />

  <style>
    :root {
      --bg: #f8f8f8;
      --fg: #0f0f0f;
      --btn: #111;
      --btn-fg: #fff;
      --accent: #ff85a1;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, "Noto Sans", Arial, sans-serif;
      -webkit-font-smoothing: antialiased;
      text-rendering: optimizeLegibility;
      display: grid;
      place-items: center;
      gap: 16px;
    }

    .wrap {
      width: min(100vw, 480px);
      height: 100vh;
      padding: env(safe-area-inset-top) 0 env(safe-area-inset-bottom);
    }

    .stage {
      position: relative;
      width: 100%;
      aspect-ratio: 9/16;
      border-radius: 16px;
      overflow: hidden;
      background: #000;
      box-shadow: 0 10px 40px rgba(0, 0, 0, .15);
    }

    .poster,
    video {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    .poster {
      opacity: 0;
      transition: opacity 250ms linear;
    }

    video {
      opacity: 0;
      transition: opacity 200ms linear;
    }

    .overlayText {
      position: absolute;
      left: 50%;
      top: 63%;
      transform: translate(-50%, -50%);
      width: 72%;
      padding: 10px 12px;
      text-align: center;
      background: rgba(255, 255, 255, 0.85);
      border-radius: 8px;
      font-size: clamp(14px, 2.6vw, 20px);
      line-height: 1.25;
      font-weight: 600;
      color: #222;
      text-wrap: balance;
      filter: drop-shadow(0 2px 6px rgba(0, 0, 0, .2));
      opacity: 0;
      transition: opacity 180ms ease-out;
      /* Tip: при необходимости сдвинь положение под свой клип */
    }

    .controls {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin-top: 12px;
    }

    button {
      -webkit-tap-highlight-color: transparent;
      cursor: pointer;
      border: 0;
      border-radius: 999px;
      padding: 12px 18px;
      font-size: 16px;
      font-weight: 600;
      background: var(--btn);
      color: var(--btn-fg);
      box-shadow: 0 6px 18px rgba(0, 0, 0, .12);
      transition: all 200ms ease;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: scale(0.95);
    }

    .hint {
      text-align: center;
      font-size: 12px;
      opacity: .6;
      margin-top: 8px;
    }

    .loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
      color: white;
      font-size: 18px;
      font-weight: 600;
      z-index: 10;
    }

    .loading-progress {
      width: 200px;
      height: 6px;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 3px;
      overflow: hidden;
      margin: 0 auto 16px;
      position: relative;
    }

    .loading-progress-bar {
      height: 100%;
      background: linear-gradient(90deg, #ff85a1, #ff6b9d);
      border-radius: 3px;
      width: 0%;
      transition: width 0.3s ease;
      position: relative;
    }

    .loading-progress-bar::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.4), transparent);
      animation: shimmer 1.5s infinite;
    }

    @keyframes shimmer {
      0% {
        transform: translateX(-100%);
      }

      100% {
        transform: translateX(100%);
      }
    }

    .loading-text {
      font-size: 14px;
      opacity: 0.9;
    }

    .stage.loading .poster,
    .stage.loading video {
      opacity: 0;
    }

    .start-screen {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 20;
      opacity: 0;
      transition: opacity 0.5s ease;
    }

    .start-screen.visible {
      opacity: 1;
    }

    .start-screen .poster {
      border-radius: 12px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
      margin-bottom: 32px;
      opacity: 1 !important;
      /* Принудительно показываем постер на экране запуска */
      background: #333;
      /* Fallback фон если изображение не загрузится */
      min-height: 200px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 14px;
    }

    .start-btn {
      background: transparent;
      /* Временный яркий фон для отладки */
      border: 2px solid white;
      color: white;
      font-size: 18px;
      font-weight: 600;
      padding: 16px 32px;
      border-radius: 999px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 1px;
      position: relative;
      z-index: 21;
      opacity: 1 !important;
      visibility: visible !important;
      display: block !important;
      min-width: 120px;
      min-height: 50px;
    }

    .start-btn:hover {
      background: #ff85a263;
      color: white;
      box-shadow: 0 8px 24px rgba(255, 133, 161, 0.4);
    }

    .start-btn:active {
      transform: translateY(0);
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="stage loading" id="stage">
      <!-- Индикатор загрузки -->
      <div class="loading" id="loadingIndicator">
        <div class="loading-progress">
          <div class="loading-progress-bar" id="progressBar"></div>
        </div>
        <div class="loading-text" id="loadingText">Загрузка...</div>
        <div class="loading-details" id="loadingDetails" style="font-size: 12px; opacity: 0.7; margin-top: 8px;"></div>
      </div>

      <img id="poster" class="poster" src="poster.jpg" alt="Baku poster" />

      <!-- Видеодорожки -->
      <video id="v-bouquet" playsinline webkit-playsinline muted preload="auto" poster="poster.jpg"></video>
      <video id="v-paper" playsinline webkit-playsinline muted preload="auto" poster="poster.jpg"></video>
      <video id="v-heart" playsinline webkit-playsinline muted preload="auto" poster="poster.jpg"></video>

      <!-- Надпись поверх листа (показывается только во время клипа paper) -->
      <div id="overlayText" class="overlayText"></div>

      <!-- Экран запуска -->
      <div id="startScreen" class="start-screen">
        <img id="startPoster" class="poster" src="poster.jpg" alt="Baku poster" />
        <button id="startBtn" class="start-btn">Начать</button>
      </div>
    </div>

    <div class="controls">
      <button id="rewindBtn">На начало</button>
      <button id="againBtn">Ещё раз</button>
    </div>
  </div>


  <script>
    (function () {
      const qs = new URLSearchParams(location.search);
      const msg = qs.get('msg') || '';

      // Устанавливаем русские тексты напрямую

      // Map клипов (элементы будут созданы динамически)
      const clips = [
        { id: 'bouquet', el: null, src: 'bouquet.mp4', weight: 1 },
        { id: 'paper', el: null, src: 'paper.mp4', weight: 1 },
        { id: 'heart', el: null, src: 'heart.mp4', weight: 1 }
      ];


      // Система предзагрузки с реальным прогрессом
      async function fetchWithProgress (url, onProgress) {
        const response = await fetch(url);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);

        const contentLength = +response.headers.get('Content-Length');
        if (!contentLength) {
          // Если размер неизвестен, загружаем как обычно
          const blob = await response.blob();
          onProgress(blob.size, blob.size);
          return blob;
        }

        const reader = response.body.getReader();
        const chunks = [];
        let receivedLength = 0;

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          chunks.push(value);
          receivedLength += value.length;
          onProgress(receivedLength, contentLength);
        }

        // Собираем все чанки в один Uint8Array
        const chunksAll = new Uint8Array(receivedLength);
        let position = 0;
        for (const chunk of chunks) {
          chunksAll.set(chunk, position);
          position += chunk.length;
        }

        return new Blob([chunksAll]);
      }

      async function preloadVideos (urls, onProgress) {
        const items = [];

        for (let i = 0; i < urls.length; i++) {
          const url = urls[i];
          const fileName = url.split('/').pop();

          onProgress(0, 100, `Загрузка ${fileName}...`, `Файл ${i + 1} из ${urls.length}`);

          const blob = await fetchWithProgress(url, (loaded, total) => {
            const fileProgress = Math.round((loaded / total) * 100);
            const overallProgress = Math.round(((i + (loaded / total)) / urls.length) * 100);
            const sizeInfo = `${Math.round(loaded / 1024)}KB / ${Math.round(total / 1024)}KB`;
            onProgress(overallProgress, 100, `Загрузка ${fileName}... ${fileProgress}%`, sizeInfo);
          });

          const objectUrl = URL.createObjectURL(blob);
          const el = document.createElement("video");
          el.src = objectUrl;
          el.muted = true;
          el.playsInline = true;
          el.style.position = 'absolute';
          el.style.inset = '0';
          el.style.width = '100%';
          el.style.height = '100%';
          el.style.objectFit = 'cover';
          el.style.opacity = '0';
          el.style.transition = 'opacity 200ms linear';

          document.getElementById('stage').appendChild(el);
          items.push({ url, objectUrl, element: el });

          onProgress(Math.round(((i + 1) / urls.length) * 100), 100, `${fileName} загружен`, 'Обработка видео...');
        }

        // Ждем готовности всех видео
        onProgress(90, 100, 'Подготовка видео...', 'Ожидание готовности к воспроизведению');
        await Promise.all(items.map(({ element }) =>
          new Promise(resolve => {
            element.addEventListener("canplaythrough", resolve, { once: true });
            element.addEventListener("loadedmetadata", resolve, { once: true });
            element.load();
          })
        ));

        return { items };
      }


      const poster = document.getElementById('poster');
      const overlay = document.getElementById('overlayText');
      const rewindBtn = document.getElementById('rewindBtn');
      const againBtn = document.getElementById('againBtn');
      const stage = document.getElementById('stage');
      const loadingIndicator = document.getElementById('loadingIndicator');
      const progressBar = document.getElementById('progressBar');
      const loadingText = document.getElementById('loadingText');
      const loadingDetails = document.getElementById('loadingDetails');
      const startScreen = document.getElementById('startScreen');
      const startBtn = document.getElementById('startBtn');

      // Рендер текста для клипа paper
      overlay.textContent = msg;
      overlay.style.display = msg ? 'block' : 'none';

      let lastId = null;
      let current = null;
      let reverseInterval = null; // Отслеживание активного интервала обратного воспроизведения
      let isReversing = false; // Флаг для предотвращения повторных вызовов

      // Простая обработка ошибок
      function showError (message) {
        console.error(message);
      }

      // Настройки
      const CONFIG = {
        videoPlaybackRate: 1.3,
        rewindSpeed: 5.0,
        rewindInterval: 30,
        fadeDuration: 200,
        autoStartDelay: 100
      };

      function pickNext () {
        // исключаем повтор предыдущего
        const pool = clips.filter(c => c.id !== lastId);
        return pool[Math.floor(Math.random() * pool.length)];
      }

      function fadeIn (el) {
        el.style.transition = `opacity ${CONFIG.fadeDuration}ms linear`;
        el.style.opacity = '1';
      }
      function fadeOut (el) {
        el.style.transition = `opacity ${CONFIG.fadeDuration}ms linear`;
        el.style.opacity = '0';
      }

      function showPoster () { poster.style.opacity = '1'; }
      function hidePoster () { poster.style.opacity = '0'; }
      function showOverlay () { if (msg) overlay.style.opacity = '1'; }
      function hideOverlay () { overlay.style.opacity = '0'; }

      function stopAll () {
        if (reverseInterval) {
          clearInterval(reverseInterval);
          reverseInterval = null;
        }
        isReversing = false;
        for (const c of clips) {
          c.el.pause();
          c.el.currentTime = 0;
          c.el.style.opacity = '0';
        }
      }

      function onEnded () {
        hideOverlay();
        rewindBtn.disabled = false;
        againBtn.disabled = false;
      }

      function rewindToStart () {
        if (isReversing) return;

        rewindBtn.disabled = true;
        againBtn.disabled = true;

        if (current && current.el.currentTime > 0) {
          if (reverseInterval) {
            clearInterval(reverseInterval);
            reverseInterval = null;
          }

          isReversing = true;
          const video = current.el;

          reverseInterval = setInterval(() => {
            const newTime = video.currentTime - (CONFIG.rewindInterval / 1000) * CONFIG.rewindSpeed;

            if (newTime <= 0) {
              clearInterval(reverseInterval);
              reverseInterval = null;
              video.currentTime = 0;
              video.pause();
              current = null;
              isReversing = false;
              rewindBtn.disabled = false;
              againBtn.disabled = false;
            } else {
              video.currentTime = newTime;
            }
          }, CONFIG.rewindInterval);
        } else {
          rewindBtn.disabled = false;
          againBtn.disabled = false;
        }
      }

      function playNext () {
        if (isReversing) return;

        rewindBtn.disabled = true;
        againBtn.disabled = true;

        if (current && current.el.currentTime > 0) {
          if (reverseInterval) {
            clearInterval(reverseInterval);
            reverseInterval = null;
          }

          isReversing = true;
          const video = current.el;

          reverseInterval = setInterval(() => {
            const newTime = video.currentTime - (CONFIG.rewindInterval / 1000) * CONFIG.rewindSpeed;

            if (newTime <= 0) {
              clearInterval(reverseInterval);
              reverseInterval = null;
              video.currentTime = 0;
              video.pause();
              current = null;
              isReversing = false;
              playNext();
              return;
            } else {
              video.currentTime = newTime;
            }
          }, CONFIG.rewindInterval);
          return;
        }

        const next = pickNext();
        lastId = next.id;
        current = next;
        const videoToPlay = next.el;

        videoToPlay.playbackRate = CONFIG.videoPlaybackRate;
        videoToPlay.currentTime = 0;
        videoToPlay.addEventListener('ended', onEnded, { once: true });

        hidePoster();
        videoToPlay.style.opacity = '1';
        if (next.id === 'paper') showOverlay();

        videoToPlay.play().catch(e => {
          console.error('Ошибка воспроизведения:', e);
          showPoster();
          videoToPlay.style.opacity = '0';
          rewindBtn.disabled = false;
          againBtn.disabled = false;
        });

        setTimeout(() => {
          clips.forEach(c => {
            if (c.id !== next.id) {
              c.el.pause();
              c.el.currentTime = 0;
              c.el.style.opacity = '0';
            }
          });
        }, 200);
      }

      rewindBtn.addEventListener('click', () => {
        if (!rewindBtn.disabled && !isReversing) rewindToStart();
      });

      againBtn.addEventListener('click', () => {
        if (!againBtn.disabled && !isReversing) playNext();
      });

      async function waitForAssets () {
        let progress = 0;
        let currentTask = 'Инициализация...';

        function updateUI (progressValue, task, details) {
          progress = progressValue;
          progressBar.style.width = `${progress}%`;
          loadingText.textContent = task || `Загрузка... ${Math.round(progress)}%`;
          if (details) {
            loadingDetails.textContent = details;
          }
        }

        try {
          // Загружаем постер
          updateUI(5, 'Загрузка постера...', 'poster.jpg');
          await new Promise(resolve => {
            if (poster.complete) resolve();
            else poster.addEventListener('load', resolve, { once: true });
          });
          updateUI(10, 'Постер загружен', 'Готов к отображению');

          // Загружаем видео с реальным прогрессом
          const videoUrls = clips.map(c => c.src);
          const { items } = await preloadVideos(videoUrls, (progressValue, total, task, details) => {
            // Масштабируем прогресс видео от 10% до 90%
            const scaledProgress = 10 + (progressValue / 100) * 80;
            updateUI(scaledProgress, task, details);
          });

          clips.forEach((clip, index) => {
            clip.el = items[index].element;
          });

          updateUI(100, 'Готово!', 'Все ресурсы загружены');

          setTimeout(() => {
            loadingIndicator.style.display = 'none';
            stage.classList.remove('loading');
            startScreen.classList.add('visible');
          }, 500);

        } catch (error) {
          console.error('Ошибка загрузки:', error);
          updateUI(100, 'Ошибка загрузки', error.message);
          setTimeout(() => {
            loadingIndicator.style.display = 'none';
            stage.classList.remove('loading');
            startScreen.classList.add('visible');
          }, 500);
        }
      }

      function startApplication () {
        startScreen.classList.remove('visible');
        showPoster();
        setTimeout(playNext, CONFIG.autoStartDelay);
      }

      startBtn.addEventListener('click', startApplication);
      waitForAssets();

    })();
  </script>
</body>

</html>
